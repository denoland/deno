{
  "name": "make-fetch-happen",
  "description": "Opinionated, caching, retrying fetch client",
  "dist-tags": {
    "latest": "13.0.1"
  },
  "versions": {
    "13.0.1": {
      "name": "make-fetch-happen",
      "version": "13.0.1",
      "author": {
        "name": "GitHub Inc."
      },
      "license": "ISC",
      "_id": "make-fetch-happen@13.0.1",
      "bugs": {
        "url": "https://github.com/npm/make-fetch-happen/issues"
      },
      "tap": {
        "color": 1,
        "files": "test/*.js",
        "nyc-arg": [
          "--exclude",
          "tap-snapshots/**"
        ],
        "timeout": 60,
        "check-coverage": true
      },
      "dist": {
        "shasum": "273ba2f78f45e1f3a6dca91cede87d9fa4821e36",
        "tarball": "http://localhost:4260/make-fetch-happen/make-fetch-happen-13.0.1.tgz",
        "fileCount": 13,
        "integrity": "sha512-cKTUFc/rbKUd/9meOvgrpJ2WrNzymt6jfRDdwg5UCnVzv9dTpEj9JS5m3wtziXVCjluIXyL8pcaukYqezIzZQA==",
        "signatures": [
          {
            "sig": "MEQCIA7a7b2hrtmuR9wWgjUVT2P4QyG21Hl7HvygsnEsFXPmAiBMMHCNEuyCw6YnMFh0lhvBpgQ/f2jefYql9X40r/Wh+g==",
            "keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"
          }
        ],
        "attestations": {
          "url": "http://localhost:4260/attestations/make-fetch-happen@13.0.1",
          "provenance": {
            "predicateType": "https://slsa.dev/provenance/v1"
          }
        },
        "unpackedSize": 52787
      },
      "main": "lib/index.js",
      "engines": {
        "node": "^16.14.0 || >=18.0.0"
      },
      "gitHead": "0b3ba78667f9984e42a32a73adde2ebd7ea1b671",
      "scripts": {
        "lint": "eslint \"**/*.{js,cjs,ts,mjs,jsx,tsx}\"",
        "snap": "tap",
        "test": "tap",
        "eslint": "eslint",
        "lintfix": "npm run lint -- --fix",
        "postlint": "template-oss-check",
        "posttest": "npm run lint",
        "template-oss-apply": "template-oss-apply --force"
      },
      "repository": {
        "url": "git+https://github.com/npm/make-fetch-happen.git",
        "type": "git"
      },
      "_npmVersion": "10.6.0",
      "description": "Opinionated, caching, retrying fetch client",
      "directories": {},
      "templateOSS": {
        "publish": "true",
        "version": "4.21.4",
        "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten."
      },
      "_nodeVersion": "20.12.2",
      "dependencies": {
        "ssri": "^10.0.0",
        "cacache": "^18.0.0",
        "minipass": "^7.0.2",
        "proc-log": "^4.2.0",
        "is-lambda": "^1.0.1",
        "negotiator": "^0.6.3",
        "@npmcli/agent": "^2.0.0",
        "promise-retry": "^2.0.1",
        "minipass-fetch": "^3.0.0",
        "minipass-flush": "^1.0.5",
        "minipass-pipeline": "^1.2.4",
        "http-cache-semantics": "^4.1.1"
      },
      "_hasShrinkwrap": false,
      "devDependencies": {
        "tap": "^16.0.0",
        "nock": "^13.2.4",
        "safe-buffer": "^5.2.1",
        "standard-version": "^9.3.2",
        "@npmcli/template-oss": "4.21.4",
        "@npmcli/eslint-config": "^4.0.0"
      }
    }
  },
  "author": {
    "name": "GitHub Inc."
  },
  "repository": {
    "url": "git+https://github.com/npm/make-fetch-happen.git",
    "type": "git"
  },
  "license": "ISC",
  "homepage": "https://github.com/npm/make-fetch-happen#readme",
  "bugs": {
    "url": "https://github.com/npm/make-fetch-happen/issues"
  },
  "readme": "# make-fetch-happen\n[![npm version](https://img.shields.io/npm/v/make-fetch-happen.svg)](https://npm.im/make-fetch-happen) [![license](https://img.shields.io/npm/l/make-fetch-happen.svg)](https://npm.im/make-fetch-happen) [![Travis](https://img.shields.io/travis/npm/make-fetch-happen.svg)](https://travis-ci.org/npm/make-fetch-happen) [![Coverage Status](https://coveralls.io/repos/github/npm/make-fetch-happen/badge.svg?branch=latest)](https://coveralls.io/github/npm/make-fetch-happen?branch=latest)\n\n[`make-fetch-happen`](https://github.com/npm/make-fetch-happen) is a Node.js\nlibrary that wraps [`minipass-fetch`](https://github.com/npm/minipass-fetch) with additional\nfeatures [`minipass-fetch`](https://github.com/npm/minipass-fetch) doesn't intend to include, including HTTP Cache support, request\npooling, proxies, retries, [and more](#features)!\n\n## Install\n\n`$ npm install --save make-fetch-happen`\n\n## Table of Contents\n\n* [Example](#example)\n* [Features](#features)\n* [Contributing](#contributing)\n* [API](#api)\n  * [`fetch`](#fetch)\n  * [`fetch.defaults`](#fetch-defaults)\n  * [`minipass-fetch` options](#minipass-fetch-options)\n  * [`make-fetch-happen` options](#extra-options)\n    * [`opts.cachePath`](#opts-cache-path)\n    * [`opts.cache`](#opts-cache)\n    * [`opts.cacheAdditionalHeaders`](#opts-cache-additional-headers)\n    * [`opts.proxy`](#opts-proxy)\n    * [`opts.noProxy`](#opts-no-proxy)\n    * [`opts.ca, opts.cert, opts.key`](#https-opts)\n    * [`opts.maxSockets`](#opts-max-sockets)\n    * [`opts.retry`](#opts-retry)\n    * [`opts.onRetry`](#opts-onretry)\n    * [`opts.integrity`](#opts-integrity)\n    * [`opts.dns`](#opts-dns)\n* [Message From Our Sponsors](#wow)\n\n### Example\n\n```javascript\nconst fetch = require('make-fetch-happen').defaults({\n  cachePath: './my-cache' // path where cache will be written (and read)\n})\n\nfetch('https://registry.npmjs.org/make-fetch-happen').then(res => {\n  return res.json() // download the body as JSON\n}).then(body => {\n  console.log(`got ${body.name} from web`)\n  return fetch('https://registry.npmjs.org/make-fetch-happen', {\n    cache: 'no-cache' // forces a conditional request\n  })\n}).then(res => {\n  console.log(res.status) // 304! cache validated!\n  return res.json().then(body => {\n    console.log(`got ${body.name} from cache`)\n  })\n})\n```\n\n### Features\n\n* Builds around [`minipass-fetch`](https://npm.im/minipass-fetch) for the core [`fetch` API](https://fetch.spec.whatwg.org) implementation\n* Request pooling out of the box\n* Quite fast, really\n* Automatic HTTP-semantics-aware request retries\n* Cache-fallback automatic \"offline mode\"\n* Built-in request caching following full HTTP caching rules (`Cache-Control`, `ETag`, `304`s, cache fallback on error, etc).\n* Node.js Stream support\n* Transparent gzip and deflate support\n* [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) support\n* Proxy support (http, https, socks, socks4, socks5. via [`@npmcli/agent`](https://npm.im/@npmcli/agent))\n* DNS cache (via ([`@npmcli/agent`](https://npm.im/@npmcli/agent))\n\n#### <a name=\"fetch\"></a> `> fetch(uriOrRequest, [opts]) -> Promise<Response>`\n\nThis function implements most of the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch): given a `uri` string or a `Request` instance, it will fire off an http request and return a Promise containing the relevant response.\n\nIf `opts` is provided, the [`minipass-fetch`-specific options](#minipass-fetch-options) will be passed to that library. There are also [additional options](#extra-options) specific to make-fetch-happen that add various features, such as HTTP caching, integrity verification, proxy support, and more.\n\n##### Example\n\n```javascript\nfetch('https://google.com').then(res => res.buffer())\n```\n\n#### <a name=\"fetch-defaults\"></a> `> fetch.defaults([defaultUrl], [defaultOpts])`\n\nReturns a new `fetch` function that will call `make-fetch-happen` using `defaultUrl` and `defaultOpts` as default values to any calls.\n\nA defaulted `fetch` will also have a `.defaults()` method, so they can be chained.\n\n##### Example\n\n```javascript\nconst fetch = require('make-fetch-happen').defaults({\n  cachePath: './my-local-cache'\n})\n\nfetch('https://registry.npmjs.org/make-fetch-happen') // will always use the cache\n```\n\n#### <a name=\"minipass-fetch-options\"></a> `> minipass-fetch options`\n\nThe following options for `minipass-fetch` are used as-is:\n\n* method\n* body\n* redirect\n* follow\n* timeout\n* compress\n* size\n\nThese other options are modified or augmented by make-fetch-happen:\n\n* headers - Default `User-Agent` set to make-fetch happen. `Connection` is set to `keep-alive` or `close` automatically depending on `opts.agent`.\n\nFor more details, see [the documentation for `minipass-fetch` itself](https://github.com/npm/minipass-fetch#options).\n\n#### <a name=\"extra-options\"></a> `> make-fetch-happen options`\n\nmake-fetch-happen augments the `minipass-fetch` API with additional features available through extra options. The following extra options are available:\n\n* [`opts.cachePath`](#opts-cache-path) - Cache target to read/write\n* [`opts.cache`](#opts-cache) - `fetch` cache mode. Controls cache *behavior*.\n* [`opts.cacheAdditionalHeaders`](#opts-cache-additional-headers) - Store additional headers in the cache\n* [`opts.proxy`](#opts-proxy) - Proxy agent\n* [`opts.noProxy`](#opts-no-proxy) - Domain segments to disable proxying for.\n* [`opts.ca, opts.cert, opts.key, opts.strictSSL`](#https-opts)\n* [`opts.localAddress`](#opts-local-address)\n* [`opts.maxSockets`](#opts-max-sockets)\n* [`opts.retry`](#opts-retry) - Request retry settings\n* [`opts.onRetry`](#opts-onretry) - a function called whenever a retry is attempted\n* [`opts.integrity`](#opts-integrity) - [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) metadata.\n* [`opts.dns`](#opts-dns) - DNS cache options\n* [`opts.agent`](#opts-agent) - http/https/proxy/socks agent options.  See [`@npmcli/agent`](https://npm.im/@npmcli/agent) for more info.\n\n#### <a name=\"opts-cache-path\"></a> `> opts.cachePath`\n\nA string `Path` to be used as the cache root for [`cacache`](https://npm.im/cacache).\n\n**NOTE**: Requests will not be cached unless their response bodies are consumed. You will need to use one of the `res.json()`, `res.buffer()`, etc methods on the response, or drain the `res.body` stream, in order for it to be written.\n\nThe default cache manager also adds the following headers to cached responses:\n\n* `X-Local-Cache`: Path to the cache the content was found in\n* `X-Local-Cache-Key`: Unique cache entry key for this response\n* `X-Local-Cache-Mode`: Always `stream` to indicate how the response was read from cacache\n* `X-Local-Cache-Hash`: Specific integrity hash for the cached entry\n* `X-Local-Cache-Status`: One of `miss`, `hit`, `stale`, `revalidated`, `updated`, or `skip` to signal how the response was created\n* `X-Local-Cache-Time`: UTCString of the cache insertion time for the entry\n\nUsing [`cacache`](https://npm.im/cacache), a call like this may be used to\nmanually fetch the cached entry:\n\n```javascript\nconst h = response.headers\ncacache.get(h.get('x-local-cache'), h.get('x-local-cache-key'))\n\n// grab content only, directly:\ncacache.get.byDigest(h.get('x-local-cache'), h.get('x-local-cache-hash'))\n```\n\n##### Example\n\n```javascript\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  cachePath: './my-local-cache'\n}) // -> 200-level response will be written to disk\n```\n\n#### <a name=\"opts-cache\"></a> `> opts.cache`\n\nThis option follows the standard `fetch` API cache option. This option will do nothing if [`opts.cachePath`](#opts-cache-path) is null. The following values are accepted (as strings):\n\n* `default` - Fetch will inspect the HTTP cache on the way to the network. If there is a fresh response it will be used. If there is a stale response a conditional request will be created, and a normal request otherwise. It then updates the HTTP cache with the response. If the revalidation request fails (for example, on a 500 or if you're offline), the stale response will be returned.\n* `no-store` - Fetch behaves as if there is no HTTP cache at all.\n* `reload` - Fetch behaves as if there is no HTTP cache on the way to the network. Ergo, it creates a normal request and updates the HTTP cache with the response.\n* `no-cache` - Fetch creates a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.\n* `force-cache` - Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it creates a normal request and updates the HTTP cache with the response.\n* `only-if-cached` - Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it returns a network error. (Can only be used when requestâ€™s mode is \"same-origin\". Any cached redirects will be followed assuming requestâ€™s redirect mode is \"follow\" and the redirects do not violate requestâ€™s mode.)\n\n(Note: option descriptions are taken from https://fetch.spec.whatwg.org/#http-network-or-cache-fetch)\n\n##### Example\n\n```javascript\nconst fetch = require('make-fetch-happen').defaults({\n  cachePath: './my-cache'\n})\n\n// Will error with ENOTCACHED if we haven't already cached this url\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  cache: 'only-if-cached'\n})\n\n// Will refresh any local content and cache the new response\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  cache: 'reload'\n})\n\n// Will use any local data, even if stale. Otherwise, will hit network.\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  cache: 'force-cache'\n})\n```\n\n#### <a name=\"opts-cache-additional-headers\"></a> `> opts.cacheAdditionalHeaders`\n\nThe following headers are always stored in the cache when present:\n\n- `cache-control`\n- `content-encoding`\n- `content-language`\n- `content-type`\n- `date`\n- `etag`\n- `expires`\n- `last-modified`\n- `link`\n- `location`\n- `pragma`\n- `vary`\n\nThis option allows a user to store additional custom headers in the cache.\n\n\n##### Example\n\n```javascript\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  cacheAdditionalHeaders: ['my-custom-header'],\n})\n```\n\n#### <a name=\"opts-proxy\"></a> `> opts.proxy`\n\nA string or `new url.URL()`-d URI to proxy through. Different Proxy handlers will be\nused depending on the proxy's protocol.\n\nAdditionally, `process.env.HTTP_PROXY`, `process.env.HTTPS_PROXY`, and\n`process.env.PROXY` are used if present and no `opts.proxy` value is provided.\n\n(Pending) `process.env.NO_PROXY` may also be configured to skip proxying requests for all, or specific domains.\n\n##### Example\n\n```javascript\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  proxy: 'https://corporate.yourcompany.proxy:4445'\n})\n\nfetch('https://registry.npmjs.org/make-fetch-happen', {\n  proxy: {\n    protocol: 'https:',\n    hostname: 'corporate.yourcompany.proxy',\n    port: 4445\n  }\n})\n```\n\n#### <a name=\"opts-no-proxy\"></a> `> opts.noProxy`\n\nIf present, should be a comma-separated string or an array of domain extensions\nthat a proxy should _not_ be used for.\n\nThis option may also be provided through `process.env.NO_PROXY`.\n\n#### <a name=\"https-opts\"></a> `> opts.ca, opts.cert, opts.key, opts.strictSSL`\n\nThese values are passed in directly to the HTTPS agent and will be used for both\nproxied and unproxied outgoing HTTPS requests. They mostly correspond to the\nsame options the `https` module accepts, which will be themselves passed to\n`tls.connect()`. `opts.strictSSL` corresponds to `rejectUnauthorized`.\n\n#### <a name=\"opts-local-address\"></a> `> opts.localAddress`\n\nPassed directly to `http` and `https` request calls. Determines the local\naddress to bind to.\n\n#### <a name=\"opts-max-sockets\"></a> `> opts.maxSockets`\n\nDefault: 15\n\nMaximum number of active concurrent sockets to use for the underlying\nHttp/Https/Proxy agents. This setting applies once per spawned agent.\n\n15 is probably a _pretty good value_ for most use-cases, and balances speed\nwith, uh, not knocking out people's routers. ðŸ¤“\n\n#### <a name=\"opts-retry\"></a> `> opts.retry`\n\nAn object that can be used to tune request retry settings. Retries will only be attempted on the following conditions:\n\n* Request method is NOT `POST` AND\n* Request status is one of: `408`, `420`, `429`, or any status in the 500-range. OR\n* Request errored with `ECONNRESET`, `ECONNREFUSED`, `EADDRINUSE`, `ETIMEDOUT`, or the `fetch` error `request-timeout`.\n\nThe following are worth noting as explicitly not retried:\n\n* `getaddrinfo ENOTFOUND` and will be assumed to be either an unreachable domain or the user will be assumed offline. If a response is cached, it will be returned immediately.\n\nIf `opts.retry` is `false`, it is equivalent to `{retries: 0}`\n\nIf `opts.retry` is a number, it is equivalent to `{retries: num}`\n\nThe following retry options are available if you want more control over it:\n\n* retries\n* factor\n* minTimeout\n* maxTimeout\n* randomize\n\nFor details on what each of these do, refer to the [`retry`](https://npm.im/retry) documentation.\n\n##### Example\n\n```javascript\nfetch('https://flaky.site.com', {\n  retry: {\n    retries: 10,\n    randomize: true\n  }\n})\n\nfetch('http://reliable.site.com', {\n  retry: false\n})\n\nfetch('http://one-more.site.com', {\n  retry: 3\n})\n```\n\n#### <a name=\"opts-onretry\"></a> `> opts.onRetry`\n\nA function called with the response or error which caused the retry whenever one is attempted.\n\n##### Example\n\n```javascript\nfetch('https://flaky.site.com', {\n  onRetry(cause) {\n    console.log('we will retry because of', cause)\n  }\n})\n```\n\n#### <a name=\"opts-integrity\"></a> `> opts.integrity`\n\nMatches the response body against the given [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) metadata. If verification fails, the request will fail with an `EINTEGRITY` error.\n\n`integrity` may either be a string or an [`ssri`](https://npm.im/ssri) `Integrity`-like.\n\n##### Example\n\n```javascript\nfetch('http://localhost:4260/make-fetch-happen/make-fetch-happen-1.0.0.tgz', {\n  integrity: 'sha1-o47j7zAYnedYFn1dF/fR9OV3z8Q='\n}) // -> ok\n\nfetch('https://malicious-registry.org/make-fetch-happen/-/make-fetch-happen-1.0.0.tgz', {\n  integrity: 'sha1-o47j7zAYnedYFn1dF/fR9OV3z8Q='\n}) // Error: EINTEGRITY\n```\n",
  "readmeFilename": "README.md"
}
