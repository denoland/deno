{"name":"smart-buffer","description":"smart-buffer is a Buffer wrapper that adds automatic read & write offset tracking, string operations, data insertions, and more.","dist-tags":{"latest":"4.2.0"},"versions":{"4.2.0":{"name":"smart-buffer","version":"4.2.0","description":"smart-buffer is a Buffer wrapper that adds automatic read & write offset tracking, string operations, data insertions, and more.","main":"build/smartbuffer.js","repository":{"type":"git","url":"git+https://github.com/JoshGlazebrook/smart-buffer.git"},"bugs":{"url":"https://github.com/JoshGlazebrook/smart-buffer/issues"},"engines":{"node":">= 6.0.0","npm":">= 3.0.0"},"author":{"name":"Josh Glazebrook"},"license":"MIT","devDependencies":{"@types/chai":"4.1.7","@types/mocha":"5.2.7","@types/node":"^12.0.0","chai":"4.2.0","coveralls":"3.0.5","istanbul":"^0.4.5","mocha":"6.2.0","mocha-lcov-reporter":"^1.3.0","nyc":"14.1.1","source-map-support":"0.5.12","ts-node":"8.3.0","tslint":"5.18.0","typescript":"^3.2.1"},"typings":"typings/smartbuffer.d.ts","dependencies":{},"scripts":{"prepublish":"npm install -g typescript && npm run build","test":"NODE_ENV=test mocha --recursive --require ts-node/register test/**/*.ts","coverage":"NODE_ENV=test nyc npm test","coveralls":"NODE_ENV=test nyc npm test && nyc report --reporter=text-lcov | coveralls","lint":"tslint --type-check --project tsconfig.json 'src/**/*.ts'","build":"tsc -p ./"},"nyc":{"extension":[".ts",".tsx"],"include":["src/*.ts","src/**/*.ts"],"exclude":["**.*.d.ts","node_modules","typings"],"require":["ts-node/register"],"reporter":["json","html"],"all":true},"gitHead":"2ce01c95312343325997b19e52daa166dc227930","_id":"smart-buffer@4.2.0","_nodeVersion":"12.15.0","_npmVersion":"6.13.4","dist":{"integrity":"sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==","shasum":"6e1d71fa4f18c05f7d0ff216dd16a481d0e8d9ae","tarball":"http://localhost:4260/smart-buffer/smart-buffer-4.2.0.tgz","fileCount":14,"unpackedSize":138027,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhDiXOCRA9TVsSAnZWagAAO+QP/2F5Wr4uJuTKXv22jQzC\nGrjpvP2kqaVTOWMd9kOo4OhRBz0LKaNLhHnLM+ckGod0bb8ZwbjgV/9KRNCd\ngRwgA7vqgt2a9PMyviSAf/54BmpShO5enI4e0fWnr9aRaYxjIjno7h7YTmLD\nd6X6Qovlz3KO9yEuPDZtzWpUDVpdUm+ut8ekjlWfgcXsnCb8Q5BhYCp35+X6\n7f9C74u0fxoP97iFQzZ9BNdSeSqv3VGxSRnS4lITSwTw0k+DAbSsHjFUwXrM\nfsSo3JaMI1iuX9HpEufszMnLy8MjPUmCY1vLZc+ELrU+K8JvD2Msj/I2MJPy\nHsxLXiKwGFQGV16Lj0je2PeS3U89bCJxq1oU+Q8duNzYcDCRmQTJQrfBsxyJ\nWV2DH2JyeJd0rLmHf1vSCx84t5kQeUJKZR9B7pDAwVwvjXQ/dLB7TJNqD2kk\niC8Tk/LRXJgYQPSPKW713pw8YClI0xFgkciub0CJAUDFIpfHaG3/GuWkze75\n+7DbuuW80XvfybmKOwLhqmwpK3UIk1BZ0ro9lusgr5X4P9pB7/DV2NUdb3nM\nhXLP+w1mcY4/RLh3vB8VnrgnUOikrG+v1WRa5e9MKVP64Ykk0bray01nQebA\nX5i823xrgi/LA7Bpr8yTt6J9MA176Wqt69kaxnsxmbEd6Iie6e4C9gXEVxSH\nAUG5\r\n=r499\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC2wZLWHAReJz5sxVMo9/DxoDHiB46pLxSOQcVFoFbZzQIgKVNzYK1Jg9+fPpdcQ86zDDaKl6OxyiFv/D3TeWcRskM="}]},"directories":{},"_hasShrinkwrap":false}},"readme":"smart-buffer  [![Build Status](https://travis-ci.org/JoshGlazebrook/smart-buffer.svg?branch=master)](https://travis-ci.org/JoshGlazebrook/smart-buffer)  [![Coverage Status](https://coveralls.io/repos/github/JoshGlazebrook/smart-buffer/badge.svg?branch=master)](https://coveralls.io/github/JoshGlazebrook/smart-buffer?branch=master)\n=============\n\nsmart-buffer is a Buffer wrapper that adds automatic read & write offset tracking, string operations, data insertions, and more.\n\n![stats](https://nodei.co/npm/smart-buffer.png?downloads=true&downloadRank=true&stars=true \"stats\")\n\n**Key Features**:\n* Proxies all of the Buffer write and read functions\n* Keeps track of read and write offsets automatically\n* Grows the internal Buffer as needed\n* Useful string operations. (Null terminating strings)\n* Allows for inserting values at specific points in the Buffer\n* Built in TypeScript\n* Type Definitions Provided\n* Browser Support (using Webpack/Browserify)\n* Full test coverage\n\n**Requirements**:\n* Node v4.0+ is supported at this time.  (Versions prior to 2.0 will work on node 0.10)\n\n\n\n## Breaking Changes in v4.0\n\n* Old constructor patterns have been completely removed. It's now required to use the SmartBuffer.fromXXX() factory constructors.\n* rewind(), skip(), moveTo() have been removed. (see [offsets](#offsets))\n* Internal private properties are now prefixed with underscores (_)\n* **All** writeXXX() methods that are given an offset will now **overwrite data** instead of insert. (see [write vs insert](#write-vs-insert))\n* insertXXX() methods have been added for when you want to insert data at a specific offset (this replaces the old behavior of writeXXX() when an offset was provided)\n\n\n## Looking for v3 docs?\n\nLegacy documentation for version 3 and prior can be found [here](https://github.com/JoshGlazebrook/smart-buffer/blob/master/docs/README_v3.md).\n\n## Installing:\n\n`yarn add smart-buffer`\n\nor\n\n`npm install smart-buffer`\n\nNote: The published NPM package includes the built javascript library.\nIf you cloned this repo and wish to build the library manually use:\n\n`npm run build`\n\n## Using smart-buffer\n\n```javascript\n// Javascript\nconst SmartBuffer = require('smart-buffer').SmartBuffer;\n\n// Typescript\nimport { SmartBuffer, SmartBufferOptions} from 'smart-buffer';\n```\n\n### Simple Example\n\nBuilding a packet that uses the following protocol specification:\n\n`[PacketType:2][PacketLength:2][Data:XX]`\n\nTo build this packet using the vanilla Buffer class, you would have to count up the length of the data payload beforehand. You would also need to keep track of the current \"cursor\" position in your Buffer so you write everything in the right places. With smart-buffer you don't have to do either of those things.\n\n```javascript\nfunction createLoginPacket(username, password, age, country) {\n    const packet = new SmartBuffer();\n    packet.writeUInt16LE(0x0060); // Some packet type\n    packet.writeStringNT(username);\n    packet.writeStringNT(password);\n    packet.writeUInt8(age);\n    packet.writeStringNT(country);\n    packet.insertUInt16LE(packet.length - 2, 2);\n\n    return packet.toBuffer();\n}\n```\nWith the above function, you now can do this:\n```javascript\nconst login = createLoginPacket(\"Josh\", \"secret123\", 22, \"United States\");\n\n// <Buffer 60 00 1e 00 4a 6f 73 68 00 73 65 63 72 65 74 31 32 33 00 16 55 6e 69 74 65 64 20 53 74 61 74 65 73 00>\n```\nNotice that the `[PacketLength:2]` value (1e 00) was inserted at position 2.\n\nReading back the packet we created above is just as easy:\n```javascript\n\nconst reader = SmartBuffer.fromBuffer(login);\n\nconst logininfo = {\n    packetType: reader.readUInt16LE(),\n    packetLength: reader.readUInt16LE(),\n    username: reader.readStringNT(),\n    password: reader.readStringNT(),\n    age: reader.readUInt8(),\n    country: reader.readStringNT()\n};\n\n/*\n{\n    packetType: 96, (0x0060)\n    packetLength: 30,\n    username: 'Josh',\n    password: 'secret123',\n    age: 22,\n    country: 'United States'\n}\n*/\n```\n\n\n## Write vs Insert\nIn prior versions of SmartBuffer, .writeXXX(value, offset) calls would insert data when an offset was provided. In version 4, this will now overwrite the data at the offset position. To insert data there are now corresponding .insertXXX(value, offset) methods.\n\n**SmartBuffer v3**:\n```javascript\nconst buff = SmartBuffer.fromBuffer(new Buffer([1,2,3,4,5,6]));\nbuff.writeInt8(7, 2);\nconsole.log(buff.toBuffer())\n\n// <Buffer 01 02 07 03 04 05 06>\n```\n\n**SmartBuffer v4**:\n```javascript\nconst buff = SmartBuffer.fromBuffer(new Buffer([1,2,3,4,5,6]));\nbuff.writeInt8(7, 2);\nconsole.log(buff.toBuffer());\n\n// <Buffer 01 02 07 04 05 06>\n```\n\nTo insert you instead should use:\n```javascript\nconst buff = SmartBuffer.fromBuffer(new Buffer([1,2,3,4,5,6]));\nbuff.insertInt8(7, 2);\nconsole.log(buff.toBuffer());\n\n// <Buffer 01 02 07 03 04 05 06>\n```\n\n**Note:** Insert/Writing to a position beyond the currently tracked internal Buffer will zero pad to your offset.\n\n## Constructing a smart-buffer\n\nThere are a few different ways to construct a SmartBuffer instance.\n\n```javascript\n// Creating SmartBuffer from existing Buffer\nconst buff = SmartBuffer.fromBuffer(buffer); // Creates instance from buffer. (Uses default utf8 encoding)\nconst buff = SmartBuffer.fromBuffer(buffer, 'ascii'); // Creates instance from buffer with ascii encoding for strings.\n\n// Creating SmartBuffer with specified internal Buffer size. (Note: this is not a hard cap, the internal buffer will grow as needed).\nconst buff = SmartBuffer.fromSize(1024); // Creates instance with internal Buffer size of 1024.\nconst buff = SmartBuffer.fromSize(1024, 'utf8'); // Creates instance with internal Buffer size of 1024, and utf8 encoding for strings.\n\n// Creating SmartBuffer with options object. This one specifies size and encoding.\nconst buff = SmartBuffer.fromOptions({\n    size: 1024,\n    encoding: 'ascii'\n});\n\n// Creating SmartBuffer with options object. This one specified an existing Buffer.\nconst buff = SmartBuffer.fromOptions({\n    buff: buffer\n});\n\n// Creating SmartBuffer from a string.\nconst buff = SmartBuffer.fromBuffer(Buffer.from('some string', 'utf8'));\n\n// Just want a regular SmartBuffer with all default options?\nconst buff = new SmartBuffer();\n```\n\n# Api Reference:\n\n**Note:** SmartBuffer is fully documented with Typescript definitions as well as jsdocs so your favorite editor/IDE will have intellisense.\n\n**Table of Contents**\n\n1. [Constructing](#constructing)\n2. **Numbers**\n    1. [Integers](#integers)\n    2. [Floating Points](#floating-point-numbers)\n3. **Strings**\n    1. [Strings](#strings)\n    2. [Null Terminated Strings](#null-terminated-strings)\n4. [Buffers](#buffers)\n5. [Offsets](#offsets)\n6. [Other](#other)\n\n\n## Constructing\n\n### constructor()\n### constructor([options])\n- ```options``` *{SmartBufferOptions}* An optional options object to construct a SmartBuffer with.\n\nExamples:\n```javascript\nconst buff = new SmartBuffer();\nconst buff = new SmartBuffer({\n    size: 1024,\n    encoding: 'ascii'\n});\n```\n\n### Class Method: fromBuffer(buffer[, encoding])\n- ```buffer``` *{Buffer}* The Buffer instance to wrap.\n- ```encoding``` *{string}* The string encoding to use. ```Default: 'utf8'```\n\nExamples:\n```javascript\nconst someBuffer = Buffer.from('some string');\nconst buff = SmartBuffer.fromBuffer(someBuffer); // Defaults to utf8\nconst buff = SmartBuffer.fromBuffer(someBuffer, 'ascii');\n```\n\n### Class Method: fromSize(size[, encoding])\n- ```size``` *{number}* The size to initialize the internal Buffer.\n- ```encoding``` *{string}* The string encoding to use. ```Default: 'utf8'```\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromSize(1024); // Defaults to utf8\nconst buff = SmartBuffer.fromSize(1024, 'ascii');\n```\n\n### Class Method: fromOptions(options)\n- ```options``` *{SmartBufferOptions}* The Buffer instance to wrap.\n\n```typescript\ninterface SmartBufferOptions {\n    encoding?: BufferEncoding; // Defaults to utf8\n    size?: number; // Defaults to 4096\n    buff?: Buffer;\n}\n```\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromOptions({\n    size: 1024\n};\nconst buff = SmartBuffer.fromOptions({\n    size: 1024,\n    encoding: 'utf8'\n});\nconst buff = SmartBuffer.fromOptions({\n    encoding: 'utf8'\n});\n\nconst someBuff = Buffer.from('some string', 'utf8');\nconst buff = SmartBuffer.fromOptions({\n    buffer: someBuff,\n    encoding: 'utf8'\n});\n```\n\n## Integers\n\n### buff.readInt8([offset])\n### buff.readUInt8([offset])\n- ```offset``` *{number}* Optional position to start reading data from. **Default**: ```Auto managed offset```\n- Returns *{number}*\n\nRead a Int8 value.\n\n### buff.readInt16BE([offset])\n### buff.readInt16LE([offset])\n### buff.readUInt16BE([offset])\n### buff.readUInt16LE([offset])\n- ```offset``` *{number}* Optional position to start reading data from. **Default**: ```Auto managed offset```\n- Returns *{number}*\n\nRead a 16 bit integer value.\n\n### buff.readInt32BE([offset])\n### buff.readInt32LE([offset])\n### buff.readUInt32BE([offset])\n### buff.readUInt32LE([offset])\n- ```offset``` *{number}* Optional position to start reading data from. **Default**: ```Auto managed offset```\n- Returns *{number}*\n\nRead a 32 bit integer value.\n\n\n### buff.writeInt8(value[, offset])\n### buff.writeUInt8(value[, offset])\n- ```value``` *{number}* The value to write.\n- ```offset``` *{number}* An optional offset to write this value to. **Default:** ```Auto managed offset```\n- Returns *{this}*\n\nWrite a Int8 value.\n\n### buff.insertInt8(value, offset)\n### buff.insertUInt8(value, offset)\n- ```value``` *{number}* The value to insert.\n- ```offset``` *{number}* The offset to insert this data at.\n- Returns *{this}*\n\nInsert a Int8 value.\n\n\n### buff.writeInt16BE(value[, offset])\n### buff.writeInt16LE(value[, offset])\n### buff.writeUInt16BE(value[, offset])\n### buff.writeUInt16LE(value[, offset])\n- ```value``` *{number}* The value to write.\n- ```offset``` *{number}* An optional offset to write this value to. **Default:** ```Auto managed offset```\n- Returns *{this}*\n\nWrite a 16 bit integer value.\n\n### buff.insertInt16BE(value, offset)\n### buff.insertInt16LE(value, offset)\n### buff.insertUInt16BE(value, offset)\n### buff.insertUInt16LE(value, offset)\n- ```value``` *{number}* The value to insert.\n- ```offset``` *{number}* The offset to insert this data at.\n- Returns *{this}*\n\nInsert a 16 bit integer value.\n\n\n### buff.writeInt32BE(value[, offset])\n### buff.writeInt32LE(value[, offset])\n### buff.writeUInt32BE(value[, offset])\n### buff.writeUInt32LE(value[, offset])\n- ```value``` *{number}* The value to write.\n- ```offset``` *{number}* An optional offset to write this value to. **Default:** ```Auto managed offset```\n- Returns *{this}*\n\nWrite a 32 bit integer value.\n\n### buff.insertInt32BE(value, offset)\n### buff.insertInt32LE(value, offset)\n### buff.insertUInt32BE(value, offset)\n### buff.nsertUInt32LE(value, offset)\n- ```value``` *{number}* The value to insert.\n- ```offset``` *{number}* The offset to insert this data at.\n- Returns *{this}*\n\nInsert a 32 bit integer value.\n\n\n## Floating Point Numbers\n\n### buff.readFloatBE([offset])\n### buff.readFloatLE([offset])\n- ```offset``` *{number}* Optional position to start reading data from. **Default**: ```Auto managed offset```\n- Returns *{number}*\n\nRead a Float value.\n\n### buff.readDoubleBE([offset])\n### buff.readDoubleLE([offset])\n- ```offset``` *{number}* Optional position to start reading data from. **Default**: ```Auto managed offset```\n- Returns *{number}*\n\nRead a Double value.\n\n\n### buff.writeFloatBE(value[, offset])\n### buff.writeFloatLE(value[, offset])\n- ```value``` *{number}* The value to write.\n- ```offset``` *{number}* An optional offset to write this value to. **Default:** ```Auto managed offset```\n- Returns *{this}*\n\nWrite a Float value.\n\n### buff.insertFloatBE(value, offset)\n### buff.insertFloatLE(value, offset)\n- ```value``` *{number}* The value to insert.\n- ```offset``` *{number}* The offset to insert this data at.\n- Returns *{this}*\n\nInsert a Float value.\n\n\n### buff.writeDoubleBE(value[, offset])\n### buff.writeDoubleLE(value[, offset])\n- ```value``` *{number}* The value to write.\n- ```offset``` *{number}* An optional offset to write this value to. **Default:** ```Auto managed offset```\n- Returns *{this}*\n\nWrite a Double value.\n\n### buff.insertDoubleBE(value, offset)\n### buff.insertDoubleLE(value, offset)\n- ```value``` *{number}* The value to insert.\n- ```offset``` *{number}* The offset to insert this data at.\n- Returns *{this}*\n\nInsert a Double value.\n\n## Strings\n\n### buff.readString()\n### buff.readString(size[, encoding])\n### buff.readString(encoding)\n- ```size``` *{number}* The number of bytes to read. **Default:** ```Reads to the end of the Buffer.```\n- ```encoding``` *{string}* The string encoding to use. **Default:** ```utf8```.\n\nRead a string value.\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromBuffer(Buffer.from('hello there', 'utf8'));\nbuff.readString(); // 'hello there'\nbuff.readString(2); // 'he'\nbuff.readString(2, 'utf8'); // 'he'\nbuff.readString('utf8'); // 'hello there'\n```\n\n### buff.writeString(value)\n### buff.writeString(value[, offset])\n### buff.writeString(value[, encoding])\n### buff.writeString(value[, offset[, encoding]])\n- ```value``` *{string}* The string value to write.\n- ```offset``` *{number}* The offset to write this value to. **Default:** ```Auto managed offset```\n- ```encoding``` *{string}* An optional string encoding to use. **Default:** ```utf8```\n\nWrite a string value.\n\nExamples:\n```javascript\nbuff.writeString('hello'); // Auto managed offset\nbuff.writeString('hello', 2);\nbuff.writeString('hello', 'utf8') // Auto managed offset\nbuff.writeString('hello', 2, 'utf8');\n```\n\n### buff.insertString(value, offset[, encoding])\n- ```value``` *{string}* The string value to write.\n- ```offset``` *{number}* The offset to write this value to.\n- ```encoding``` *{string}* An optional string encoding to use. **Default:** ```utf8```\n\nInsert a string value.\n\nExamples:\n```javascript\nbuff.insertString('hello', 2);\nbuff.insertString('hello', 2, 'utf8');\n```\n\n## Null Terminated Strings\n\n### buff.readStringNT()\n### buff.readStringNT(encoding)\n- ```encoding``` *{string}* The string encoding to use. **Default:** ```utf8```.\n\nRead a null terminated string value. (If a null is not found, it will read to the end of the Buffer).\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromBuffer(Buffer.from('hello\\0 there', 'utf8'));\nbuff.readStringNT(); // 'hello'\n\n// If we called this again:\nbuff.readStringNT(); // ' there'\n```\n\n### buff.writeStringNT(value)\n### buff.writeStringNT(value[, offset])\n### buff.writeStringNT(value[, encoding])\n### buff.writeStringNT(value[, offset[, encoding]])\n- ```value``` *{string}* The string value to write.\n- ```offset``` *{number}* The offset to write this value to. **Default:** ```Auto managed offset```\n- ```encoding``` *{string}* An optional string encoding to use. **Default:** ```utf8```\n\nWrite a null terminated string value.\n\nExamples:\n```javascript\nbuff.writeStringNT('hello'); // Auto managed offset   <Buffer 68 65 6c 6c 6f 00>\nbuff.writeStringNT('hello', 2); // <Buffer 00 00 68 65 6c 6c 6f 00>\nbuff.writeStringNT('hello', 'utf8') // Auto managed offset\nbuff.writeStringNT('hello', 2, 'utf8');\n```\n\n### buff.insertStringNT(value, offset[, encoding])\n- ```value``` *{string}* The string value to write.\n- ```offset``` *{number}* The offset to write this value to.\n- ```encoding``` *{string}* An optional string encoding to use. **Default:** ```utf8```\n\nInsert a null terminated string value.\n\nExamples:\n```javascript\nbuff.insertStringNT('hello', 2);\nbuff.insertStringNT('hello', 2, 'utf8');\n```\n\n## Buffers\n\n### buff.readBuffer([length])\n- ```length``` *{number}* The number of bytes to read into a Buffer. **Default:** ```Reads to the end of the Buffer```\n\nRead a Buffer of a specified size.\n\n### buff.writeBuffer(value[, offset])\n- ```value``` *{Buffer}* The buffer value to write.\n- ```offset``` *{number}* An optional offset to write the value to. **Default:** ```Auto managed offset```\n\n### buff.insertBuffer(value, offset)\n- ```value``` *{Buffer}* The buffer value to write.\n- ```offset``` *{number}* The offset to write the value to.\n\n\n### buff.readBufferNT()\n\nRead a null terminated Buffer.\n\n### buff.writeBufferNT(value[, offset])\n- ```value``` *{Buffer}* The buffer value to write.\n- ```offset``` *{number}* An optional offset to write the value to. **Default:** ```Auto managed offset```\n\nWrite a null terminated Buffer.\n\n\n### buff.insertBufferNT(value, offset)\n- ```value``` *{Buffer}* The buffer value to write.\n- ```offset``` *{number}* The offset to write the value to.\n\nInsert a null terminated Buffer.\n\n\n## Offsets\n\n### buff.readOffset\n### buff.readOffset(offset)\n- ```offset``` *{number}* The new read offset value to set.\n- Returns: ```The current read offset```\n\nGets or sets the current read offset.\n\nExamples:\n```javascript\nconst currentOffset = buff.readOffset; // 5\n\nbuff.readOffset = 10;\n\nconsole.log(buff.readOffset) // 10\n```\n\n### buff.writeOffset\n### buff.writeOffset(offset)\n- ```offset``` *{number}* The new write offset value to set.\n- Returns: ```The current write offset```\n\nGets or sets the current write offset.\n\nExamples:\n```javascript\nconst currentOffset = buff.writeOffset; // 5\n\nbuff.writeOffset = 10;\n\nconsole.log(buff.writeOffset) // 10\n```\n\n### buff.encoding\n### buff.encoding(encoding)\n- ```encoding``` *{string}* The new string encoding to set.\n- Returns: ```The current string encoding```\n\nGets or sets the current string encoding.\n\nExamples:\n```javascript\nconst currentEncoding = buff.encoding; // 'utf8'\n\nbuff.encoding = 'ascii';\n\nconsole.log(buff.encoding) // 'ascii'\n```\n\n## Other\n\n### buff.clear()\n\nClear and resets the SmartBuffer instance.\n\n### buff.remaining()\n- Returns ```Remaining data left to be read```\n\nGets the number of remaining bytes to be read.\n\n\n### buff.internalBuffer\n- Returns: *{Buffer}*\n\nGets the internally managed Buffer (Includes unmanaged data).\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromSize(16);\nbuff.writeString('hello');\nconsole.log(buff.InternalBuffer); // <Buffer 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00>\n```\n\n### buff.toBuffer()\n- Returns: *{Buffer}*\n\nGets a sliced Buffer instance of the internally managed Buffer. (Only includes managed data)\n\nExamples:\n```javascript\nconst buff = SmartBuffer.fromSize(16);\nbuff.writeString('hello');\nconsole.log(buff.toBuffer()); // <Buffer 68 65 6c 6c 6f>\n```\n\n### buff.toString([encoding])\n- ```encoding``` *{string}* The string encoding to use when converting to a string. **Default:** ```utf8```\n- Returns *{string}*\n\nGets a string representation of all data in the SmartBuffer.\n\n### buff.destroy()\n\nDestroys the SmartBuffer instance.\n\n\n\n## License\n\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n","author":{"name":"Josh Glazebrook"},"repository":{"type":"git","url":"git+https://github.com/JoshGlazebrook/smart-buffer.git"},"readmeFilename":"README.md","homepage":"https://github.com/JoshGlazebrook/smart-buffer/","bugs":{"url":"https://github.com/JoshGlazebrook/smart-buffer/issues"},"license":"MIT"}
