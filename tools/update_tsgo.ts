#!/usr/bin/env -S deno run -RWN --allow-run=deno
// Copyright 2018-2025 the Deno authors. MIT license.

import { fileURLToPath } from "node:url";

/**
 * Trims the minimum indent from each line of a multiline string,
 * removing leading and trailing blank lines.
 * @param text
 * @returns the trimmed string
 */
export function trimIndent(text: string): string {
  if (text.startsWith("\n")) {
    text = text.slice(1);
  }
  const lines = text.split("\n");
  const nonEmptyLines = lines.filter((line) => line.trim().length > 0);
  const indent = nonEmptyLines.length > 0
    ? Math.min(
      ...nonEmptyLines.map((line) => line.length - line.trimStart().length),
    )
    : 0;

  return lines
    .map((line) => {
      if (line.length <= indent) {
        return line.replace(/^ +/, "");
      } else {
        return line.slice(indent);
      }
    })
    .join("\n");
}

export function unindent(strings: TemplateStringsArray, ...values: unknown[]) {
  // normal template substitution
  const raw = String.raw({ raw: strings }, ...values);
  return trimIndent(raw);
}

const repo = "nathanwhit/typescript-go-rs";

export interface GitHubRelease {
  url: string;
  assets_url: string;
  upload_url: string;
  html_url: string;
  id: number;
  author: GitHubUser;
  node_id: string;
  tag_name: string;
  target_commitish: string;
  name: string;
  draft: boolean;
  immutable: boolean;
  prerelease: boolean;
  created_at: string; // ISO timestamp
  updated_at: string; // ISO timestamp
  published_at: string; // ISO timestamp
  assets: GitHubAsset[];
  tarball_url: string;
  zipball_url: string;
  body: string;
}

export interface GitHubUser {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string; // "User" | "Bot" | "Organization"
  user_view_type: string; // e.g. "public"
  site_admin: boolean;
}

export interface GitHubAsset {
  url: string;
  id: number;
  node_id: string;
  name: string;
  label: string;
  uploader: GitHubUser;
  content_type: string;
  state: string; // e.g. "uploaded"
  size: number; // in bytes
  digest: string; // sha256:...
  download_count: number;
  created_at: string; // ISO timestamp
  updated_at: string; // ISO timestamp
  browser_download_url: string;
}

const latest = await fetch(
  `https://api.github.com/repos/${repo}/releases/latest`,
).then((res) => res.json()) as GitHubRelease;

const version = latest.tag_name;

const file = fileURLToPath(import.meta.resolve(
  "../cli/tsc/go/tsgo_version.rs",
));

const content = await Deno.readTextFile(file);
const match = content.match(/const VERSION: &str = "([^"]+)"/);
let currentVersion = "";
if (!match) {
  currentVersion = "";
} else {
  currentVersion = match[1];
}
console.log("Current version: ", currentVersion);
if (currentVersion === version) {
  console.log("Version is up to date, updating generated code");
} else {
  console.log("Updating version to: ", version);
}

function findHashes(
  release: GitHubRelease,
): {
  windows_x64: string;
  macos_x64: string;
  macos_arm64: string;
  linux_x64: string;
  linux_arm64: string;
} {
  const hashes = {
    windows_x64: "",
    macos_x64: "",
    macos_arm64: "",
    linux_x64: "",
    linux_arm64: "",
  };
  for (const asset of release.assets) {
    const parts = asset.name.split("-");
    const os = parts[parts.length - 2];
    const archAndExtension = parts[parts.length - 1];
    const arch = archAndExtension.split(".")[0];
    if (os === "windows" && arch === "x64") {
      hashes.windows_x64 = asset.digest;
    } else if (os === "macos" && arch === "x64") {
      hashes.macos_x64 = asset.digest;
    } else if (os === "macos" && arch === "arm64") {
      hashes.macos_arm64 = asset.digest;
    } else if (os === "linux" && arch === "x64") {
      hashes.linux_x64 = asset.digest;
    } else if (os === "linux" && arch === "arm64") {
      hashes.linux_arm64 = asset.digest;
    }
  }
  return hashes;
}

const hashes = findHashes(latest);
for (const [platform, hash] of Object.entries(hashes)) {
  if (!hash) {
    console.error(`No hashes found for ${platform}`);
    Deno.exit(1);
  }
}
const newContent = unindent`
  // Copyright 2018-2025 the Deno authors. MIT license.

  // This file is auto-generated by tools/update_tsgo.ts
  // DO NOT EDIT THIS FILE MANUALLY

  pub struct Hashes {
    pub windows_x64: &'static str,
    pub macos_x64: &'static str,
    pub macos_arm64: &'static str,
    pub linux_x64: &'static str,
    pub linux_arm64: &'static str,
  }
  pub const VERSION: &str = "${version}";
  pub const DOWNLOAD_BASE_URL: &str = "https://github.com/${repo}/releases/download/${version}";
  pub const HASHES: Hashes = Hashes {
    windows_x64: "${hashes.windows_x64}",
    macos_x64: "${hashes.macos_x64}",
    macos_arm64: "${hashes.macos_arm64}",
    linux_x64: "${hashes.linux_x64}",
    linux_arm64: "${hashes.linux_arm64}",
  };
`;

await Deno.writeTextFile(file, newContent);

if (currentVersion !== version) {
  console.log("Version updated to ", version);
}

await import("./format.js");
