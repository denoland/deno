// Copyright 2018-2026 the Deno authors. MIT license.

#[cfg(not(feature = "disable"))]
mod shared;

fn main() {
  #[cfg(feature = "disable")]
  return;

  #[cfg(not(feature = "disable"))]
  {
    use std::path::Path;
    use std::path::PathBuf;

    let o = PathBuf::from(std::env::var_os("OUT_DIR").unwrap());
    let snapshot_path = o.join("CLI_SNAPSHOT.bin");

    let cache_dir = get_stable_cache_dir(&o);
    let ts_version = shared::TS_VERSION;
    let target = std::env::var("TARGET").unwrap();

    // 1. Try cached snapshot generated by `cargo run -p snapshot_generator`.
    if try_use_cached_snapshot(&cache_dir, &snapshot_path, ts_version, &target) {
      return;
    }

    // OUT_DIR = <target>/<profile>/build/<crate>-<hash>/out
    //   parent^1 = <target>/<profile>/build/<crate>-<hash>/
    //   parent^2 = <target>/<profile>/build/
    //   parent^3 = <target>/<profile>/
    let target_profile_dir =
      o.parent().unwrap().parent().unwrap().parent().unwrap();
    let generator_name = if cfg!(windows) {
      "snapshot_generator.exe"
    } else {
      "snapshot_generator"
    };
    let generator_bin = target_profile_dir.join(generator_name);

    // 2. Try running existing generator binary.
    if generator_bin.exists() {
      eprintln!(
        "Snapshot is stale — auto-running snapshot_generator..."
      );
      let status = std::process::Command::new(&generator_bin)
        .status()
        .unwrap_or_else(|e| {
          panic!(
            "Failed to run snapshot generator at {}: {e}",
            generator_bin.display()
          )
        });
      if !status.success() {
        panic!(
          "Snapshot generator failed with exit code: {:?}",
          status.code()
        );
      }

      assert!(
        try_use_cached_snapshot(
          &cache_dir,
          &snapshot_path,
          ts_version,
          &target,
        ),
        "Snapshot generator ran but the snapshot is still stale. \
         This is a bug — please report it."
      );
      return;
    }

    // 3. Binary doesn't exist (fresh checkout) — auto-build and run the generator.
    // We use a separate target dir to avoid deadlocking on Cargo's file lock.
    // OUT_DIR parent^4 = <target>/
    let target_dir = target_profile_dir.parent().unwrap();
    let snapshot_target_dir = target_dir.join("snapshot_build");

    let cargo =
      std::env::var("CARGO").unwrap_or_else(|_| "cargo".to_string());

    let mut cmd = std::process::Command::new(&cargo);
    cmd
      .arg("run")
      .arg("-p")
      .arg("snapshot_generator")
      .arg("--target-dir")
      .arg(&snapshot_target_dir);
    if !cfg!(debug_assertions) {
      cmd.arg("--release");
    }
    cmd.env("SNAPSHOT_CACHE_DIR", &cache_dir);

    eprintln!(
      "Snapshot is stale — building and running snapshot_generator..."
    );
    eprintln!("(This may take a while on first build)");

    let status = cmd.status().unwrap_or_else(|e| {
      panic!("Failed to run cargo: {e}");
    });
    if !status.success() {
      panic!(
        "snapshot_generator failed (exit code {:?})",
        status.code()
      );
    }

    assert!(
      try_use_cached_snapshot(
        &cache_dir,
        &snapshot_path,
        ts_version,
        &target,
      ),
      "Snapshot generator ran but the snapshot is still stale. \
       This is a bug — please report it."
    );

    /// Check if a valid cached snapshot exists whose hash matches the
    /// current inputs. If so, copy it to the output path and emit
    /// rerun-if-changed directives. Returns true if the cache was valid.
    fn try_use_cached_snapshot(
      cache_dir: &Path,
      snapshot_path: &Path,
      ts_version: &str,
      target: &str,
    ) -> bool {
      let cache_manifest = cache_dir.join("CLI_SNAPSHOT.manifest");
      let cache_hash = cache_dir.join("CLI_SNAPSHOT.hash");
      let cache_snapshot = cache_dir.join("CLI_SNAPSHOT.bin");

      let Ok(manifest_content) = std::fs::read_to_string(&cache_manifest)
      else {
        return false;
      };
      let Ok(stored_hash) = std::fs::read_to_string(&cache_hash) else {
        return false;
      };
      if !cache_snapshot.exists() {
        return false;
      }

      let Some((v8_version, paths)) =
        deno_snapshot_hash::parse_manifest(&manifest_content)
      else {
        return false;
      };
      let path_refs: Vec<&str> = paths.iter().map(|s| s.as_str()).collect();
      let current_hash = deno_snapshot_hash::compute_hash(
        &path_refs,
        ts_version,
        &v8_version,
        target,
      );

      if current_hash != stored_hash.trim() {
        return false;
      }

      // Copy snapshot to OUT_DIR
      std::fs::copy(&cache_snapshot, snapshot_path).unwrap();
      deno_snapshot_hash::emit_rerun_from_manifest(&manifest_content);
      true
    }

    fn get_stable_cache_dir(out_dir: &Path) -> PathBuf {
      // OUT_DIR is: <target>/<profile>/build/<crate>-<hash>/out
      // Go up 2 levels to get <target>/<profile>/build/ which is stable
      // across different feature configurations.
      let build_dir = out_dir.parent().unwrap().parent().unwrap();
      let cache_dir = build_dir.join(".deno_snapshot_cache");
      std::fs::create_dir_all(&cache_dir).unwrap();
      cache_dir
    }
  }
}
