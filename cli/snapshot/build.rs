// Copyright 2018-2026 the Deno authors. MIT license.

#[cfg(not(feature = "disable"))]
mod shared;

fn main() {
  #[cfg(feature = "disable")]
  return;

  #[cfg(not(feature = "disable"))]
  {
    use std::path::Path;
    use std::path::PathBuf;

    let o = PathBuf::from(std::env::var_os("OUT_DIR").unwrap());
    let snapshot_path = o.join("CLI_SNAPSHOT.bin");

    let cache_dir = get_stable_cache_dir(&o);
    let cache_manifest = cache_dir.join("CLI_SNAPSHOT.manifest");
    let cache_hash = cache_dir.join("CLI_SNAPSHOT.hash");
    let cache_snapshot = cache_dir.join("CLI_SNAPSHOT.bin");

    // Read cached snapshot generated by `cargo run -p snapshot_generator`.
    // The manifest contains file paths and v8_version from the generator.
    // We recompute the hash from current file contents and compare against
    // the stored hash.
    if let (Ok(manifest_content), Ok(stored_hash)) = (
      std::fs::read_to_string(&cache_manifest),
      std::fs::read_to_string(&cache_hash),
    ) {
      if cache_snapshot.exists() {
        if let Some(current_hash) = compute_hash_from_manifest(
          &manifest_content,
          shared::TS_VERSION,
          &std::env::var("TARGET").unwrap(),
        ) {
          if current_hash == stored_hash {
            // Hash matches — copy snapshot to OUT_DIR if needed and return
            copy_if_changed(&cache_snapshot, &snapshot_path);
            emit_rerun_from_manifest(&manifest_content);
            return;
          }
        }
      }
    }

    // No valid cached snapshot — the snapshot generator must be run first.
    panic!(
      "Snapshot is stale or missing. Run the snapshot generator first:\n\
       cargo run -p snapshot_generator"
    );

    fn get_stable_cache_dir(out_dir: &Path) -> PathBuf {
      // OUT_DIR is: <target>/<profile>/build/<crate>-<hash>/out
      // Go up 2 levels to get <target>/<profile>/build/ which is stable
      // across different feature configurations.
      let build_dir = out_dir.parent().unwrap().parent().unwrap();
      let cache_dir = build_dir.join(".deno_snapshot_cache");
      std::fs::create_dir_all(&cache_dir).unwrap();
      cache_dir
    }

    fn copy_if_changed(src: &Path, dst: &Path) {
      // Skip copy if destination already has the same content (by size check)
      if dst.exists() {
        if let (Ok(src_meta), Ok(dst_meta)) =
          (src.metadata(), dst.metadata())
        {
          if src_meta.len() == dst_meta.len() {
            return;
          }
        }
      }
      std::fs::copy(src, dst).unwrap();
    }

    /// Recompute the snapshot hash from a manifest file without deno_runtime.
    /// Returns None if the manifest format is invalid.
    fn compute_hash_from_manifest(
      manifest: &str,
      ts_version: &str,
      target: &str,
    ) -> Option<String> {
      use std::hash::Hash;
      use std::hash::Hasher;

      let mut lines = manifest.lines();

      // Parse v8_version from first line
      let v8_line = lines.next()?;
      let v8_version = v8_line.strip_prefix("v8_version=")?;

      // Skip separator
      let sep = lines.next()?;
      if sep != "---" {
        return None;
      }

      // Collect file paths
      let paths: Vec<&str> = lines.filter(|l| !l.is_empty()).collect();

      // Compute hash using the same algorithm as runtime/snapshot.rs
      let mut hasher = std::collections::hash_map::DefaultHasher::new();
      paths.len().hash(&mut hasher);
      for path in &paths {
        path.hash(&mut hasher);
        match std::fs::read(path) {
          Ok(content) => content.hash(&mut hasher),
          Err(_) => 0u8.hash(&mut hasher),
        }
      }
      ts_version.hash(&mut hasher);
      v8_version.hash(&mut hasher);
      target.hash(&mut hasher);

      Some(format!("{:x}", hasher.finish()))
    }

    /// Emit cargo:rerun-if-changed for all file paths in the manifest.
    fn emit_rerun_from_manifest(manifest: &str) {
      let mut lines = manifest.lines();
      // Skip v8_version line and separator
      lines.next();
      lines.next();

      #[allow(clippy::print_stdout)]
      for path in lines.filter(|l| !l.is_empty()) {
        println!("cargo:rerun-if-changed={}", path);
      }
    }
  }
}
