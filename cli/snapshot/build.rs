// Copyright 2018-2026 the Deno authors. MIT license.

#[cfg(not(feature = "disable"))]
mod shared;

fn main() {
  #[cfg(feature = "disable")]
  return;

  #[cfg(not(feature = "disable"))]
  {
    use std::path::Path;
    use std::path::PathBuf;

    let o = PathBuf::from(std::env::var_os("OUT_DIR").unwrap());
    let snapshot_path = o.join("CLI_SNAPSHOT.bin");

    let cache_dir = get_stable_cache_dir(&o);
    let cache_manifest = cache_dir.join("CLI_SNAPSHOT.manifest");
    let cache_hash = cache_dir.join("CLI_SNAPSHOT.hash");
    let cache_snapshot = cache_dir.join("CLI_SNAPSHOT.bin");

    // Read cached snapshot generated by `cargo run -p snapshot_generator`.
    // The manifest contains file paths and v8_version from the generator.
    // We recompute the hash from current file contents and compare against
    // the stored hash.
    if let (Ok(manifest_content), Ok(stored_hash)) = (
      std::fs::read_to_string(&cache_manifest),
      std::fs::read_to_string(&cache_hash),
    ) {
      if cache_snapshot.exists() {
        if let Some(current_hash) = compute_hash_from_manifest(
          &manifest_content,
          shared::TS_VERSION,
          &std::env::var("TARGET").unwrap(),
        ) {
          if current_hash == stored_hash {
            // Hash matches — copy snapshot to OUT_DIR if needed and return
            copy_if_changed(&cache_snapshot, &snapshot_path);
            emit_rerun_from_manifest(&manifest_content);
            return;
          }
        }
      }
    }

    // No valid cached snapshot — try to auto-run the snapshot generator binary.
    // OUT_DIR = <target>/<profile>/build/<crate>-<hash>/out
    //   parent^1 = <target>/<profile>/build/<crate>-<hash>/
    //   parent^2 = <target>/<profile>/build/
    //   parent^3 = <target>/<profile>/
    let target_profile_dir = o.parent().unwrap().parent().unwrap().parent().unwrap();
    let generator_name = if cfg!(windows) {
      "snapshot_generator.exe"
    } else {
      "snapshot_generator"
    };
    let generator_bin = target_profile_dir.join(generator_name);

    if generator_bin.exists() {
      eprintln!(
        "Snapshot is stale — auto-running snapshot_generator..."
      );
      let status = std::process::Command::new(&generator_bin)
        .status()
        .unwrap_or_else(|e| {
          panic!(
            "Failed to run snapshot generator at {}: {e}",
            generator_bin.display()
          )
        });
      if !status.success() {
        panic!(
          "Snapshot generator failed with exit code: {:?}",
          status.code()
        );
      }

      // Re-read cache and verify snapshot is now fresh
      if let (Ok(manifest_content), Ok(stored_hash)) = (
        std::fs::read_to_string(&cache_manifest),
        std::fs::read_to_string(&cache_hash),
      ) {
        if cache_snapshot.exists() {
          if let Some(current_hash) = compute_hash_from_manifest(
            &manifest_content,
            shared::TS_VERSION,
            &std::env::var("TARGET").unwrap(),
          ) {
            if current_hash == stored_hash {
              copy_if_changed(&cache_snapshot, &snapshot_path);
              emit_rerun_from_manifest(&manifest_content);
              return;
            }
          }
        }
      }

      panic!(
        "Snapshot generator ran but the snapshot is still stale. \
         This is a bug — please report it."
      );
    }

    // Binary doesn't exist (fresh checkout) — auto-build and run the generator.
    // We use a separate target dir to avoid deadlocking on Cargo's file lock.
    let target_dir = o
      .parent()
      .unwrap()
      .parent()
      .unwrap()
      .parent()
      .unwrap()
      .parent()
      .unwrap();
    let snapshot_target_dir = target_dir.join("snapshot_build");

    let cargo =
      std::env::var("CARGO").unwrap_or_else(|_| "cargo".to_string());

    let mut cmd = std::process::Command::new(&cargo);
    cmd
      .arg("run")
      .arg("-p")
      .arg("snapshot_generator")
      .arg("--target-dir")
      .arg(&snapshot_target_dir);
    if !cfg!(debug_assertions) {
      cmd.arg("--release");
    }
    cmd.env("SNAPSHOT_CACHE_DIR", &cache_dir);

    eprintln!(
      "Snapshot is stale — building and running snapshot_generator..."
    );
    eprintln!("(This may take a while on first build)");

    let status = cmd.status().unwrap_or_else(|e| {
      panic!("Failed to run cargo: {e}");
    });
    if !status.success() {
      panic!(
        "snapshot_generator failed (exit code {:?})",
        status.code()
      );
    }

    // Re-read cache and verify snapshot is now fresh
    if let (Ok(manifest_content), Ok(stored_hash)) = (
      std::fs::read_to_string(&cache_manifest),
      std::fs::read_to_string(&cache_hash),
    ) {
      if cache_snapshot.exists() {
        if let Some(current_hash) = compute_hash_from_manifest(
          &manifest_content,
          shared::TS_VERSION,
          &std::env::var("TARGET").unwrap(),
        ) {
          if current_hash == stored_hash {
            copy_if_changed(&cache_snapshot, &snapshot_path);
            emit_rerun_from_manifest(&manifest_content);
            return;
          }
        }
      }
    }

    panic!(
      "Snapshot generator ran but the snapshot is still stale. \
       This is a bug — please report it."
    );

    fn get_stable_cache_dir(out_dir: &Path) -> PathBuf {
      // OUT_DIR is: <target>/<profile>/build/<crate>-<hash>/out
      // Go up 2 levels to get <target>/<profile>/build/ which is stable
      // across different feature configurations.
      let build_dir = out_dir.parent().unwrap().parent().unwrap();
      let cache_dir = build_dir.join(".deno_snapshot_cache");
      std::fs::create_dir_all(&cache_dir).unwrap();
      cache_dir
    }

    fn copy_if_changed(src: &Path, dst: &Path) {
      // Skip copy if destination already has the same content (by size check)
      if dst.exists() {
        if let (Ok(src_meta), Ok(dst_meta)) =
          (src.metadata(), dst.metadata())
        {
          if src_meta.len() == dst_meta.len() {
            return;
          }
        }
      }
      std::fs::copy(src, dst).unwrap();
    }

    /// Recompute the snapshot hash from a manifest file without deno_runtime.
    /// Returns None if the manifest format is invalid.
    fn compute_hash_from_manifest(
      manifest: &str,
      ts_version: &str,
      target: &str,
    ) -> Option<String> {
      use std::hash::Hash;
      use std::hash::Hasher;

      let mut lines = manifest.lines();

      // Parse v8_version from first line
      let v8_line = lines.next()?;
      let v8_version = v8_line.strip_prefix("v8_version=")?;

      // Skip separator
      let sep = lines.next()?;
      if sep != "---" {
        return None;
      }

      // Collect file paths
      let paths: Vec<&str> = lines.filter(|l| !l.is_empty()).collect();

      // Compute hash using the same algorithm as runtime/snapshot.rs
      let mut hasher = std::collections::hash_map::DefaultHasher::new();
      paths.len().hash(&mut hasher);
      for path in &paths {
        path.hash(&mut hasher);
        match std::fs::read(path) {
          Ok(content) => content.hash(&mut hasher),
          Err(_) => 0u8.hash(&mut hasher),
        }
      }
      ts_version.hash(&mut hasher);
      v8_version.hash(&mut hasher);
      target.hash(&mut hasher);

      Some(format!("{:x}", hasher.finish()))
    }

    /// Emit cargo:rerun-if-changed for all file paths in the manifest.
    fn emit_rerun_from_manifest(manifest: &str) {
      let mut lines = manifest.lines();
      // Skip v8_version line and separator
      lines.next();
      lines.next();

      #[allow(clippy::print_stdout)]
      for path in lines.filter(|l| !l.is_empty()) {
        println!("cargo:rerun-if-changed={}", path);
      }
    }
  }
}
