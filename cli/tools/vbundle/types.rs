// Copyright 2018-2026 the Deno authors. MIT license.

//! Core types for the vbundle (Vite-like bundler) module.
//!
//! This module defines the fundamental types used throughout the bundler,
//! including plugin results, resolution results, and transformation output.

use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

use deno_ast::ModuleSpecifier;
use deno_core::error::AnyError;
use deno_core::serde::Deserialize;
use deno_core::serde::Serialize;
use deno_core::sourcemap::SourceMap;

/// Result of a plugin's resolveId hook.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde")]
pub struct ResolveResult {
  /// The resolved module specifier (URL or path).
  pub id: String,
  /// Whether this module should be treated as external.
  #[serde(default)]
  pub external: bool,
  /// Optional side effects flag for tree shaking.
  #[serde(default)]
  pub side_effects: Option<bool>,
}

/// Result of a plugin's load hook.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde")]
pub struct LoadResult {
  /// The source code of the module.
  pub code: String,
  /// Optional source map (as JSON string or SourceMap).
  #[serde(default)]
  pub map: Option<String>,
  /// Media type hint (e.g., "js", "ts", "json").
  #[serde(default)]
  pub loader: Option<String>,
  /// Whether this module has side effects.
  #[serde(default)]
  pub side_effects: Option<bool>,
}

/// Result of a plugin's transform hook.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde")]
pub struct TransformResult {
  /// The transformed source code.
  pub code: String,
  /// Optional source map.
  #[serde(default)]
  pub map: Option<String>,
}

/// Result of a plugin's renderChunk hook.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde")]
pub struct RenderChunkResult {
  /// The transformed chunk code.
  pub code: String,
  /// Optional source map.
  #[serde(default)]
  pub map: Option<String>,
}

/// Information about a loaded and registered plugin.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct PluginInfo {
  /// The plugin's name.
  pub name: String,
  /// File extensions this plugin handles (e.g., [".svelte", ".vue"]).
  #[serde(default)]
  pub extensions: Vec<String>,
  /// Whether this plugin provides resolveId hook.
  #[serde(default)]
  pub has_resolve: bool,
  /// Whether this plugin provides load hook.
  #[serde(default)]
  pub has_load: bool,
  /// Whether this plugin provides transform hook.
  #[serde(default)]
  pub has_transform: bool,
  /// Whether this plugin provides buildStart hook.
  #[serde(default)]
  pub has_build_start: bool,
  /// Whether this plugin provides buildEnd hook.
  #[serde(default)]
  pub has_build_end: bool,
  /// Whether this plugin provides renderChunk hook.
  #[serde(default)]
  pub has_render_chunk: bool,
  /// Whether this plugin provides generateBundle hook.
  #[serde(default)]
  pub has_generate_bundle: bool,
  /// Plugin execution order ('pre', 'post', or None for normal).
  #[serde(default)]
  pub enforce: Option<String>,
}

/// A module that has been transformed by the bundler.
#[derive(Debug, Clone)]
pub struct TransformedModule {
  /// The original module specifier.
  pub original_specifier: ModuleSpecifier,
  /// The transformed source code.
  pub code: Arc<str>,
  /// Optional source map for error position mapping.
  pub source_map: Option<SourceMap>,
  /// The media type after transformation (always JS/TS).
  pub media_type: deno_ast::MediaType,
  /// Optional type declarations generated by the plugin.
  pub declarations: Option<String>,
}

/// Options for the resolve hook.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct ResolveOptions {
  /// Whether this is an entry point.
  #[serde(default)]
  pub is_entry: bool,
  /// The import kind (e.g., "import", "require", "dynamic").
  #[serde(default)]
  pub kind: Option<String>,
}

/// Options for the load hook.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct LoadOptions {
  /// SSR mode flag.
  #[serde(default)]
  pub ssr: bool,
}

/// Options for the transform hook.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct TransformOptions {
  /// SSR mode flag.
  #[serde(default)]
  pub ssr: bool,
}

/// Emitted file from a plugin.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct EmittedFile {
  /// The type of file being emitted.
  #[serde(rename = "type")]
  pub file_type: EmittedFileType,
  /// The file name (optional, will be generated if not provided).
  #[serde(default)]
  pub file_name: Option<String>,
  /// The file name without hash (for assets).
  #[serde(default)]
  pub name: Option<String>,
  /// Source code (for chunks).
  #[serde(default)]
  pub source: Option<String>,
}

/// Type of emitted file.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(crate = "deno_core::serde", rename_all = "lowercase")]
pub enum EmittedFileType {
  /// A JavaScript chunk.
  Chunk,
  /// An asset file (CSS, images, etc.).
  Asset,
}

/// Chunk information passed to renderChunk hook.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(crate = "deno_core::serde", rename_all = "camelCase")]
pub struct ChunkInfo {
  /// The chunk's file name.
  pub file_name: String,
  /// Whether this is an entry chunk.
  pub is_entry: bool,
  /// Whether this is a dynamic entry (code-split).
  pub is_dynamic_entry: bool,
  /// List of modules included in this chunk.
  pub modules: Vec<String>,
  /// List of chunk imports.
  pub imports: Vec<String>,
  /// List of dynamic imports.
  pub dynamic_imports: Vec<String>,
}

/// Bundle output passed to generateBundle hook.
#[derive(Debug, Clone, Default)]
pub struct BundleOutput {
  /// Map of file name to output chunk/asset.
  pub files: HashMap<String, OutputFile>,
}

/// An output file (chunk or asset).
#[derive(Debug, Clone)]
pub enum OutputFile {
  /// A JavaScript chunk.
  Chunk(OutputChunk),
  /// An asset file.
  Asset(OutputAsset),
}

/// An output JavaScript chunk.
#[derive(Debug, Clone)]
pub struct OutputChunk {
  /// The generated code.
  pub code: String,
  /// Optional source map.
  pub map: Option<String>,
  /// Whether this is an entry chunk.
  pub is_entry: bool,
  /// Whether this is a dynamic entry.
  pub is_dynamic_entry: bool,
  /// Modules included in this chunk.
  pub modules: Vec<String>,
  /// Chunk imports.
  pub imports: Vec<String>,
  /// Dynamic imports.
  pub dynamic_imports: Vec<String>,
}

/// An output asset.
#[derive(Debug, Clone)]
pub struct OutputAsset {
  /// The asset source (string or bytes).
  pub source: Vec<u8>,
  /// The original file name (if any).
  pub name: Option<String>,
}

/// Configuration for a bundler build.
#[derive(Debug, Clone)]
pub struct BuildConfig {
  /// Entry points for the build.
  pub entry_points: Vec<ModuleSpecifier>,
  /// Output directory.
  pub out_dir: PathBuf,
  /// Whether to generate source maps.
  pub sourcemap: bool,
  /// Whether to minify output.
  pub minify: bool,
  /// Target environments.
  pub environments: Vec<super::environment::BundleEnvironment>,
  /// Plugin specifiers to load.
  pub plugins: Vec<ModuleSpecifier>,
}

impl Default for BuildConfig {
  fn default() -> Self {
    Self {
      entry_points: Vec::new(),
      out_dir: PathBuf::from("dist"),
      sourcemap: true,
      minify: false,
      environments: vec![super::environment::BundleEnvironment::Server],
      plugins: Vec::new(),
    }
  }
}

/// Error type for bundler operations.
#[derive(Debug)]
pub enum BundlerError {
  /// Plugin returned an error.
  Plugin { plugin: String, message: String },
  /// Resolution failed.
  Resolution { specifier: String, message: String },
  /// Load failed.
  Load { specifier: String, message: String },
  /// Transform failed.
  Transform { specifier: String, message: String },
  /// Code generation failed.
  Emit { message: String },
  /// General error.
  Other(AnyError),
}

impl std::fmt::Display for BundlerError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      BundlerError::Plugin { plugin, message } => {
        write!(f, "Plugin '{}' error: {}", plugin, message)
      }
      BundlerError::Resolution { specifier, message } => {
        write!(f, "Failed to resolve '{}': {}", specifier, message)
      }
      BundlerError::Load { specifier, message } => {
        write!(f, "Failed to load '{}': {}", specifier, message)
      }
      BundlerError::Transform { specifier, message } => {
        write!(f, "Failed to transform '{}': {}", specifier, message)
      }
      BundlerError::Emit { message } => {
        write!(f, "Code generation error: {}", message)
      }
      BundlerError::Other(e) => write!(f, "{}", e),
    }
  }
}

impl std::error::Error for BundlerError {}

impl From<AnyError> for BundlerError {
  fn from(err: AnyError) -> Self {
    BundlerError::Other(err)
  }
}
