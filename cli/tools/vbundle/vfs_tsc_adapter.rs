// Copyright 2018-2026 the Deno authors. MIT license.

//! VFS adapter for TypeScript type checking.
//!
//! This module provides integration between the VFS and TypeScript,
//! enabling type checking of transformed files (e.g., `.svelte`, `.vue`
//! files that have been transformed to TypeScript/JavaScript).
//!
//! # How It Works
//!
//! 1. TypeScript requests file content through this adapter
//! 2. The adapter returns transformed code from the VFS
//! 3. TypeScript type-checks the transformed code
//! 4. Diagnostic positions are mapped back to the original source
//!
//! # Type Declarations
//!
//! Plugins can provide `.d.ts` declarations alongside transformed code.
//! This enables full type checking for custom file types.

use std::sync::Arc;

use deno_ast::ModuleSpecifier;
use deno_core::error::AnyError;

use super::source_map::Position;
use super::source_map::SourceRange;
use super::virtual_fs::BundlerVirtualFS;

/// A TypeScript diagnostic with position information.
#[derive(Debug, Clone)]
pub struct TsDiagnostic {
  /// The file specifier.
  pub specifier: ModuleSpecifier,
  /// The diagnostic message.
  pub message: String,
  /// The TypeScript error code.
  pub code: u32,
  /// The severity level.
  pub severity: TsSeverity,
  /// Start position in the source.
  pub start: Position,
  /// End position in the source.
  pub end: Position,
  /// Related information (e.g., where a type was inferred from).
  pub related: Vec<TsRelatedInfo>,
}

/// Severity level for TypeScript diagnostics.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TsSeverity {
  /// A type error.
  Error,
  /// A warning (e.g., deprecated API).
  Warning,
  /// A suggestion for improvement.
  Suggestion,
  /// Informational message.
  Message,
}

/// Related information for a TypeScript diagnostic.
#[derive(Debug, Clone)]
pub struct TsRelatedInfo {
  /// The file specifier.
  pub specifier: ModuleSpecifier,
  /// The message.
  pub message: String,
  /// Start position.
  pub start: Position,
  /// End position.
  pub end: Position,
}

/// Adapter for type checking files through the VFS.
pub struct VfsTscAdapter {
  /// The virtual file system.
  vfs: Arc<BundlerVirtualFS>,
  /// Declaration files generated by plugins.
  declarations: std::collections::HashMap<ModuleSpecifier, String>,
}

impl VfsTscAdapter {
  /// Create a new VFS TypeScript adapter.
  pub fn new(vfs: Arc<BundlerVirtualFS>) -> Self {
    Self {
      vfs,
      declarations: std::collections::HashMap::new(),
    }
  }

  /// Get file content for TypeScript (transformed if needed).
  pub async fn get_file_content(
    &self,
    specifier: &ModuleSpecifier,
  ) -> Result<String, AnyError> {
    let transformed = self.vfs.load(specifier).await?;
    Ok(transformed.code.to_string())
  }

  /// Get file content synchronously (from cache).
  pub fn get_file_content_sync(&self, specifier: &ModuleSpecifier) -> Option<String> {
    // Try to get from VFS cache
    if let Some(source) = self.vfs.get_original_source(specifier) {
      // If not transformed, return original
      if !self.vfs.needs_transform(specifier) {
        return Some(source);
      }
    }

    // For transformed files, we need the async path
    // Return None to indicate async load needed
    None
  }

  /// Check if a file exists in the VFS.
  pub fn file_exists(&self, specifier: &ModuleSpecifier) -> bool {
    // Check if it's a standard file or a transformable file
    let path = specifier.path();

    // Check for declaration file
    if path.ends_with(".d.ts") {
      if let Some(original) = self.get_original_specifier(specifier) {
        return self.declarations.contains_key(&original);
      }
    }

    // Standard existence check would go here
    // For now, return true for known file types
    let known_extensions = [
      ".ts", ".tsx", ".js", ".jsx", ".mts", ".mjs", ".d.ts", ".d.mts",
    ];

    known_extensions.iter().any(|ext| path.ends_with(ext))
      || self.vfs.needs_transform(specifier)
  }

  /// Get declaration file for a transformed module.
  pub fn get_declaration(&self, specifier: &ModuleSpecifier) -> Option<&String> {
    self.declarations.get(specifier)
  }

  /// Set declaration file for a module (called by plugins).
  pub fn set_declaration(&mut self, specifier: ModuleSpecifier, declaration: String) {
    self.declarations.insert(specifier, declaration);
  }

  /// Map TypeScript diagnostics to original source positions.
  pub fn map_diagnostics(&self, diagnostics: Vec<TsDiagnostic>) -> Vec<TsDiagnostic> {
    diagnostics
      .into_iter()
      .map(|diag| self.map_diagnostic(diag))
      .collect()
  }

  /// Map a single diagnostic's positions.
  fn map_diagnostic(&self, mut diag: TsDiagnostic) -> TsDiagnostic {
    // Only map if the file was transformed
    if !self.vfs.needs_transform(&diag.specifier) {
      return diag;
    }

    // Map main diagnostic position
    let range = SourceRange {
      start: diag.start,
      end: diag.end,
    };
    let mapped = self.vfs.map_error_range(&diag.specifier, range);
    diag.start = mapped.start;
    diag.end = mapped.end;

    // Map related info positions
    diag.related = diag
      .related
      .into_iter()
      .map(|mut info| {
        if self.vfs.needs_transform(&info.specifier) {
          let range = SourceRange {
            start: info.start,
            end: info.end,
          };
          let mapped = self.vfs.map_error_range(&info.specifier, range);
          info.start = mapped.start;
          info.end = mapped.end;
        }
        info
      })
      .collect();

    diag
  }

  /// Get the original specifier for a declaration file.
  fn get_original_specifier(&self, decl_specifier: &ModuleSpecifier) -> Option<ModuleSpecifier> {
    let path = decl_specifier.path();
    if path.ends_with(".d.ts") {
      let original_path = path.trim_end_matches(".d.ts");
      // Try common extensions
      for ext in [".svelte", ".vue", ".astro"] {
        let original = format!("{}{}", original_path, ext);
        if let Ok(spec) = ModuleSpecifier::parse(&format!(
          "{}://{}{}",
          decl_specifier.scheme(),
          decl_specifier.host_str().unwrap_or(""),
          original
        )) {
          return Some(spec);
        }
      }
    }
    None
  }

  /// Get the declaration file specifier for a module.
  pub fn get_declaration_specifier(specifier: &ModuleSpecifier) -> ModuleSpecifier {
    let path = specifier.path();
    let decl_path = format!("{}.d.ts", path);
    ModuleSpecifier::parse(&format!(
      "{}://{}{}",
      specifier.scheme(),
      specifier.host_str().unwrap_or(""),
      decl_path
    ))
    .unwrap_or_else(|_| specifier.clone())
  }
}

/// Format a TypeScript diagnostic for display.
pub fn format_ts_diagnostic(diag: &TsDiagnostic) -> String {
  let severity = match diag.severity {
    TsSeverity::Error => "error",
    TsSeverity::Warning => "warning",
    TsSeverity::Suggestion => "suggestion",
    TsSeverity::Message => "message",
  };

  let mut output = format!(
    "{} TS{}: {} at {}:{}:{}",
    severity,
    diag.code,
    diag.message,
    diag.specifier,
    diag.start.line + 1,
    diag.start.column + 1,
  );

  for info in &diag.related {
    output.push_str(&format!(
      "\n  related: {} at {}:{}:{}",
      info.message,
      info.specifier,
      info.start.line + 1,
      info.start.column + 1,
    ));
  }

  output
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_ts_severity() {
    assert_eq!(TsSeverity::Error, TsSeverity::Error);
    assert_ne!(TsSeverity::Error, TsSeverity::Warning);
  }

  #[test]
  fn test_format_ts_diagnostic() {
    let diag = TsDiagnostic {
      specifier: ModuleSpecifier::parse("file:///app/test.ts").unwrap(),
      message: "Type 'string' is not assignable to type 'number'".to_string(),
      code: 2322,
      severity: TsSeverity::Error,
      start: Position { line: 10, column: 5 },
      end: Position { line: 10, column: 15 },
      related: vec![],
    };

    let formatted = format_ts_diagnostic(&diag);
    assert!(formatted.contains("error"));
    assert!(formatted.contains("TS2322"));
    assert!(formatted.contains("test.ts"));
    assert!(formatted.contains("11:6")); // 1-indexed
  }

  #[test]
  fn test_format_ts_diagnostic_with_related() {
    let diag = TsDiagnostic {
      specifier: ModuleSpecifier::parse("file:///app/test.ts").unwrap(),
      message: "Argument of type 'A' is not assignable to parameter of type 'B'".to_string(),
      code: 2345,
      severity: TsSeverity::Error,
      start: Position { line: 20, column: 10 },
      end: Position { line: 20, column: 20 },
      related: vec![TsRelatedInfo {
        specifier: ModuleSpecifier::parse("file:///app/types.ts").unwrap(),
        message: "The expected type comes from this signature".to_string(),
        start: Position { line: 5, column: 0 },
        end: Position { line: 5, column: 30 },
      }],
    };

    let formatted = format_ts_diagnostic(&diag);
    assert!(formatted.contains("TS2345"));
    assert!(formatted.contains("related:"));
    assert!(formatted.contains("types.ts"));
  }

  #[test]
  fn test_declaration_specifier() {
    let specifier = ModuleSpecifier::parse("file:///app/Component.svelte").unwrap();
    let decl = VfsTscAdapter::get_declaration_specifier(&specifier);
    assert!(decl.path().ends_with(".svelte.d.ts"));
  }

  #[test]
  fn test_file_exists_standard() {
    let vfs = Arc::new(BundlerVirtualFS::passthrough());
    let adapter = VfsTscAdapter::new(vfs);

    // Standard TypeScript/JavaScript files should be recognized
    assert!(adapter.file_exists(&ModuleSpecifier::parse("file:///app/test.ts").unwrap()));
    assert!(adapter.file_exists(&ModuleSpecifier::parse("file:///app/test.tsx").unwrap()));
    assert!(adapter.file_exists(&ModuleSpecifier::parse("file:///app/test.js").unwrap()));
    assert!(adapter.file_exists(&ModuleSpecifier::parse("file:///app/test.mts").unwrap()));
  }

  #[test]
  fn test_declaration_file_exists() {
    let vfs = Arc::new(BundlerVirtualFS::passthrough());
    let mut adapter = VfsTscAdapter::new(vfs);

    // Add a declaration for a transformed file
    let specifier = ModuleSpecifier::parse("file:///app/Component.svelte").unwrap();
    adapter.set_declaration(specifier.clone(), "export const x: number;".to_string());

    // Check that we can get the declaration
    assert!(adapter.get_declaration(&specifier).is_some());
  }
}
