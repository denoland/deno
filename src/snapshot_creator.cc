// Copyright 2018 Ryan Dahl <ry@tinyclouds.org>
// All rights reserved. MIT License.
// Hint: --trace_serializer is a useful debugging flag.
#include <fstream>
#include "deno.h"
#include "file_util.h"
#include "internal.h"
#include "third_party/v8/include/v8.h"
#include "third_party/v8/src/base/logging.h"

namespace deno {

v8::StartupData SerializeInternalFields(v8::Local<v8::Object> holder, int index,
                                        void* data) {
  DCHECK_EQ(data, nullptr);
  InternalFieldData* embedder_field = static_cast<InternalFieldData*>(
      holder->GetAlignedPointerFromInternalField(index));
  if (embedder_field == nullptr) return {nullptr, 0};
  int size = sizeof(*embedder_field);
  char* payload = new char[size];
  // We simply use memcpy to serialize the content.
  memcpy(payload, embedder_field, size);
  return {payload, size};
}

v8::StartupData MakeSnapshot(const char* js_filename, const char* js_source) {
  auto* creator = new v8::SnapshotCreator(external_references);
  auto* isolate = creator->GetIsolate();
  v8::Isolate::Scope isolate_scope(isolate);
  {
    v8::HandleScope handle_scope(isolate);
    auto context = v8::Context::New(isolate);
    InitializeContext(isolate, context, js_filename, js_source);
    creator->SetDefaultContext(context, v8::SerializeInternalFieldsCallback(
                                            SerializeInternalFields, nullptr));
  }

  auto snapshot_blob =
      creator->CreateBlob(v8::SnapshotCreator::FunctionCodeHandling::kClear);

  return snapshot_blob;
}

class StartupDataCppWriter {
 public:
  StartupDataCppWriter(const char* name, const char* filename,
                       const std::string& data)
      : name_(name),
        filename_(filename),
        data_(data),
        file_(filename_, std::ios::binary) {}

  bool Write() {
    if (file_.bad()) {
      return false;
    }
    WritePrefix();
    WriteData();
    WriteSuffix();

    file_.close();
    // printf("Wrote %s %d %s \n", name_, data_.size(), filename_);
    return !file_.bad();
  }

 private:
  void WritePrefix() {
    file_ << "// Autogenerated snapshot file. Do not edit.\n\n";
    file_ << "#include \"third_party/v8/include/v8.h\"\n\n";
    file_ << "namespace deno { \n\n";
  }

  void WriteSuffix() {
    char buffer[500];
    snprintf(buffer, sizeof(buffer), "v8::StartupData* StartupBlob_%s() {\n",
             name_);
    file_ << buffer;
    snprintf(buffer, sizeof(buffer), "  return &%s_blob;\n", name_);
    file_ << buffer;
    file_ << "}\n\n";
    file_ << "}  // namespace deno\n\n";
  }

  void WriteData() {
    char buffer[500];
    file_ << BinaryContentAsC(name_, data_);
    snprintf(buffer, sizeof(buffer),
             "static v8::StartupData %s_blob = { %s_data, %s_size };\n", name_,
             name_, name_);
    file_ << buffer;
  }

  const char* name_;
  const char* filename_;
  std::string data_;
  std::ofstream file_;
};

}  // namespace deno

int main(int argc, char** argv) {
  const char* js_fn = argv[1];
  const char* snapshot_out_cc = argv[2];

  v8::V8::SetFlagsFromCommandLine(&argc, argv, true);

  CHECK_EQ(argc, 3);
  CHECK_NE(js_fn, nullptr);
  CHECK_NE(snapshot_out_cc, nullptr);

  std::string js_source;
  CHECK(deno::ReadFileToString(js_fn, &js_source));

  deno_init();
  auto snapshot_blob = deno::MakeSnapshot(js_fn, js_source.c_str());
  std::string snapshot_str(snapshot_blob.data, snapshot_blob.raw_size);

  deno::StartupDataCppWriter writer("snapshot", snapshot_out_cc, snapshot_str);
  CHECK(writer.Write());
}
